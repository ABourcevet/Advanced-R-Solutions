```{r, include=FALSE}
source("common.R")
```

# Function operators

```{r}
library(purrr)
```


## Existing function operators

1. __<span style="color:red">Q</span>__: Base R provides a function operator in the form of `Vectorize()`. What does it do? When might you use it?    
   
   __<span style="color:green">A</span>__: In R a lot of functions are "vectorised". This means, that a computation is iteratively applied to each element of a "vectorised argument". Further - in the context of R - the term vectorised implies that these operations are implemented in a compiled language such as C or Fortran as these languages provide faster evaluation of for loops than R does.
   
   Despite what the function's name tells us, `Vectorize()` is not able to speed up the provided function. It rather changes the input format of the supplied arguments (`vectorize.args`), so that they can be iterated over.

   In essence, `Vectorize()` is mostly a wrapper for `mapply()`. Let's take a look at an example from the documentation:

    ```{r}
    vrep <- Vectorize(rep.int)
    vrep
    
    # Application
    vrep(1:2, 3:4)
    
    # Naming arguments still works
    vrep(times = 1:2, x = 3:4)  
    ```

   `Vectorize()` provides a convenient and concise notation to iterate over multiple arguments. Because of this, `Vectorize()` works best for scalar functions. If you want your vectorised function to be type stable you might want to set `SIMPLIFY = FALSE` inside of `Vectorize()`.

2. __<span style="color:red">Q</span>__: Read the source code for `possibly()`. How does it work?
   
   __<span style="color:green">A</span>__: `possibly()` modifies functions to return a specified default value in case of an error (`otherwise`) and to suppress any error messages (`quiet = TRUE`).
   
   While reading the source code, we notice that `possibly()` internally uses `purrr::as_mapper()`. This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the purrr package. Besides this, the new default value (`otherwise`) gets evaluated once to make it (almost) immutable from now on.
   
   The main functionality of `possibly()` is provided by `base::tryCatch()`. In this part the supplied function (`.f`) gets wrapped and the error and interrupt handling are specified.
   
    ```{r}
    possibly
    ```

3. __<span style="color:red">Q</span>__: Read the source code for `safely()`. How does it work?
   
   __<span style="color:green">A</span>__: `safely()` modifies functions to return a list, containing the elements "result" and "error". It works in a similar fashion as `possibly()` and besides using `as_mapper()`, `safely()` also provides the `otherwise` and `quiet` argument. However, in order to provide the result and the error in a consistent way, the `tryCatch()` part of the implementation returns a list with the same structure in both cases. In the case of successful evaluation "error" equals to `NULL` and in case of an error "result" equals to `otherwise`, which is `NULL` by default.
   
   As the `tryCatch()` part is hidden in the internal `purrr:::capture_output()` function, we provide it here in addition to `safely()`:
   
    ```{r}
    safely
    
    purrr:::capture_error
    ```

   Take a look at the textbook or the documentation of `safely()` to see how you can take advantage of this behaviour, for example when fitting many models.

## Case study: Creating your own function operators

1. __<span style="color:red">Q</span>__: Weigh the pros and cons of `download.file %>% dot_every(10) %>% delay_by(0.1)` vs `download.file %>% delay_by(0.1) %>% dot_every(10)`.
   
   __<span style="color:green">A</span>__:
   
2. __<span style="color:red">Q</span>__: Should you memoise `file.download()`? Why/why not?
   
   __<span style="color:green">A</span>__: Before you consider to memoise `file.download()`, you should make sure that the files you want to download under a specific URL don't change. It makes sense to memoise `file.download()` in scenarios where objects are downloaded repeatedly and might take a little longer. However, the downside of caching results in memory is that the respective amount of memory will not be available for other tasks during the R session. Therefore, it not beneficial to memoise `file.download()` when it is needed to download very large files, mostly different files or time is not an issue. As the specific meaning of these terms varies in different situations, the best choice depends on the use case and one has to weigh up these trade-offs carefully.
   
3. __<span style="color:red">Q</span>__: Create a function operator that reports whenever a file is created or deleted in the working directory, using `dir()` and `setdiff()`. What other global function effects might you want to track?
   
   __<span style="color:green">A</span>__: We start with a short version to show the idea:
    
    ```{r, eval = FALSE}
    track_dir <- function(f){
      force(f)
      function(...){
        dir_old <- dir()
        on.exit(if(!setequal(dir(), dir_old)){
          message("files in your working directory were deleted or added by this function")})
        f(...)
      }
    }
    
    # This test creates the file "delete_me" in your working directory
    td <- track_dir(dir.create)
    td("delete_me")
    ```
    
   Of course we can provide more information on the type of changes:
    
    ```{r, eval = FALSE}
    track_dir <- function(f){
      force(f)
      function(...){
        dir_old <- dir()
        
        on.exit(if(!setequal(dir(), dir_old)){
          message("Files in your working directory were deleted or added by this
                  function.")}, add = TRUE)
        on.exit(if(length(setdiff(dir_old, dir()))){
          message(paste0("The following files were deleted: ",
                         paste(setdiff(dir_old, dir()), collapse = ", ")
                         ))}, add = TRUE)
        on.exit(if(length(setdiff(dir(), dir_old))){
          message(paste0("The following files were added: ", 
                         paste(setdiff(dir(), dir_old), collapse = ", ")
                         ))}, add = TRUE)
        
        f(...)
      }
    }

    # This test will create two files in your working directory
    td <- track_dir(sapply)
    td(c("delete_me", "me_too"), dir.create)
    ```
    
   To create a more serious version of `track_dir()` one might provide optionality to set the `full.names` and `recursive` arguments of `dir()` to `TRUE`. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.
   
   Other global effects that might be worth tracking include changes regarding:
    
   * the search path and possibly introduced `conflicts()`
   * `options()` and `par()` which modify global settings
   * the path of the working directory
   * environment variables
   
4. __<span style="color:red">Q</span>__: Write a function operator that logs a timestamp and message to a file every time a function is run.
   
   __<span style="color:green">A</span>__: Note that the example will (again) create a file in your current working directory:
    
    ```{r, eval = FALSE}
    logger <- function(f, prefix){
      force(f)
      filename_tmp <- paste(prefix, basename(tempfile()), sep = "_")
      write(paste("created at:", Sys.time()), filename_tmp, append = TRUE)
      function(..., message = "you can add a message at each call") {
        write(paste0("used at: ", Sys.time(), ", ", message), filename_tmp, append = TRUE)
        f(...)
      }
    }
    
    # The following line creates a file, prefixed with "mean_log_"
    mean2 <- logger(mean, "mean_log") 
    mean2(1:4, message = "first_time") 
    mean2(1:4, message = "second_time")
    ```
   
5. __<span style="color:red">Q</span>__: Modify `delay_by()` so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called `g <- delay_by(1, f); g(); Sys.sleep(2); g()` there shouldn't be an extra delay.
   
   __<span style="color:green">A</span>__: We can do this with three little tricks (and the help of 42):
    
    ```{r, eval = FALSE}
    delay_by_v2 <- function(f, amount) {
      force(f)
      force(amount)
      
      # First, we initialise the timestamp for the last run: 
      # Here, we set a specific default value, to ensure that
      # the first run of the new function will never be delayed.
      
      last_runtime <- Sys.time() - (amount + 42)
      
      function(...) {
      
        # Inside the new function we continually check via an empty
        # while statement, if enough time has passed.
        
        while (Sys.time() < last_runtime + amount) {}
        
        # Finally, set the timestamp to start the next waiting period
        # to begin after the function is evaluated.
        
        on.exit(last_runtime <<- Sys.time()) 
        
        return(f(...))
      }
    }
    ```
    
   Alternatively to the empty while statement we could have used `Sys.sleep()`. I would not recommend this solution, since `?Sys.sleep` indicates that `Sys.sleep()` might have some overhead and seems not to be as exact as we need.

<!-- MGO: Not sure, if this exercise really intends to track the time of the call or the finished evaluation of the new function. 
The current solution assumes the first case. However, regarding the latter case I would introduce two timers that jump one (timer) up, whenever the new function gets evaluated. I.e. use sth. like

```
# Initialisation
last_call <- Sys.time() - amount
this_call <- Sys.time()

# During evaluation of new function
last_call <<- this_call
this_call <-  Sys.time()
```

-->
