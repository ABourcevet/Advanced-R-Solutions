```{r, include=FALSE}
source("common.R")
```

# Rewriting R code in C++

## Getting started with C++

__[Q1]{.Q}__: With the basics of C++ in hand, it's now a great time to practice by reading and writing some simple C++ functions. For each of the following functions, read the code and figure out what the corresponding base R function is. You might not understand every part of the code yet, but you should be able to figure out the basics of what the function does.

```{Rcpp, eval=FALSE}
double f1(NumericVector x) {
  int n = x.size();
  double y = 0;
  
  for(int i = 0; i < n; ++i) {
    y += x[i] / n;
  }
  return y;
}

NumericVector f2(NumericVector x) {
  int n = x.size();
  NumericVector out(n);
  
  out[0] = x[0];
  for(int i = 1; i < n; ++i) {
    out[i] = out[i - 1] + x[i];
  }
  return out;
}

bool f3(LogicalVector x) {
  int n = x.size();
  
  for(int i = 0; i < n; ++i) {
    if (x[i]) return true;
  }
  return false;
}

int f4(Function pred, List x) {
  int n = x.size();
  
  for(int i = 0; i < n; ++i) {
    LogicalVector res = pred(x[i]);
    if (res[0]) return i + 1;
  }
  return 0;
}

NumericVector f5(NumericVector x, NumericVector y) {
  int n = std::max(x.size(), y.size());
  NumericVector x1 = rep_len(x, n);
  NumericVector y1 = rep_len(y, n);
  
  NumericVector out(n);
  
  for (int i = 0; i < n; ++i) {
    out[i] = std::min(x1[i], y1[i]);
  }
  
  return out;
}
```

__[A]{.solved}__:  The code above corresponds to the following R functions:

*   f1: `mean()`  
*   f2: `cumsum()`  
*   f3: `any()`
*   f4: `Position()`
*   f5: `pmin()`

__[Q2]{.Q}__:  To practice your function writing skills, convert the following functions into C++. For now, assume the inputs have no missing values.

1. `all()`.

2. `cumprod()`, `cummin()`, `cummax()`.

3. `diff()`. Start by assuming lag 1, and then generalise for lag `n`.

4. `range()`.

5. `var()`. Read about the approaches you can take on [Wikipedia](http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance). Whenever implementing a numerical algorithm, it's always good to check what is already known about the problem.

__[A]{.solved}__: Let's port these functions to C++.

1. `all()`

```{Rcpp, eval=FALSE}
bool allC(LogicalVector x) {
  int n = x.size();
  
  for(int i = 0; i < n; ++i) {
    if (!x[i]) return false;
  }
  return true;
}
```

2. `cumprod()`, `cummin()`, `cummax()`.

```{Rcpp, eval=FALSE}
NumericVector cumprodC(NumericVector x) {
  int n = x.size();
  NumericVector out(n);
  
  out[0] = x[0];
  for(int i = 1; i < n; ++i) {
    out[i]  = out[i - 1] * x[i];
  }
  return out;
}

NumericVector cumminC(NumericVector x) {
  int n = x.size();
  NumericVector out(n);
  
  out[0] = x[0];
  for(int i = 1; i < n; ++i) {
    out[i]  = std::min(out[i - 1], x[i]);
  }
  return out;
}

NumericVector cummaxC(NumericVector x) {
  int n = x.size();
  NumericVector out(n);
  
  out[0] = x[0];
  for(int i = 1; i < n; ++i) {
    out[i]  = std::max(out[i - 1], x[i]);
  }
  return out;
}
```

3. `diff()` (Start by assuming lag 1, and then generalise for lag `n`.)

```{Rcpp, eval=FALSE}
NumericVector diffC(NumericVector x){
  int n = x.size();
  NumericVector out(n - 1);
  
  for(int i = 1; i < n; i++){
    out[i - 1] = x[i] - x[i - 1];
  }
  return out ;
}

NumericVector difflagC(NumericVector x, int lag = 1){
  int n = x.size();
  NumericVector out(n - lag);
  
  for(int i = lag; i < n; i++){
    out[i - lag] = x[i] - x[i - lag];
  }
  return out;
}
```

<!-- HW: you might need a check here that lag is < length(x) -->

4. `range()`

```{Rcpp, eval=FALSE}
NumericVector rangeC(NumericVector x){
  double omin = x[0], omax = x[0];
  
  int n = x.size();
  for(int i = 1; i < n; i++){
    omin = std::min(x[i], omin);
    omax = std::max(x[i], omax);
  }
  
  NumericVector out(2);
  out[0] = omin;
  out[1] = omax;
  return out;
}
```
  
<!-- this needs a check that n > 0 -->
    
5. `var()`

```{Rcpp, eval=FALSE}
double varC(NumericVector x) {
  int n = x.size();
  
  if (n < 2) {
    return NA_REAL;
  }
  
  double mx = 0;
  for (int i = 0; i < n; ++i) {
    mx += x[i] / n;
  }
  
  double out = 0;
  for (int i = 0; i < n; ++i) {
    out += pow(x[i] - mx, 2);
  }
  
  return out / (n - 1);
}
```


## Missing values

__[Q1]{.Q}__:  Rewrite any of the functions from the first exercise to deal with missing values. If `na.rm` is true, ignore the missing values. If `na.rm` is false, return a missing value if the input contains any missing values. Some good functions to practice with are `min()`, `max()`, `range()`, `mean()`, and `var()`.

__[A]{.solved}__: In this exercise we choose to extend `minC()` so it can deal with missing values. We introduce an `na_rm` argument to make `minC()` aware of `NA`s. In case `x` contains exclusively `NA` values `minC()` should return `Inf` for `na_rm == TRUE`. For the return values vector data types are used to avoid irregular type conversions.

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector minC(NumericVector x, bool na_rm = false){
  int n = x.size();
  NumericVector out = NumericVector::create(R_PosInf);
  
  if (na_rm) {
    for(int i = 0; i < n; ++i) {
      if (x[i] == NA_REAL) {
        continue;
      }
      if (x[i] < out[0]) {
        out[0] = x[i];
      }
    }
  } else {
    for(int i = 0; i < n; ++i) {
      if (NumericVector::is_na(x[i])) {
        out[0] = NA_REAL;
        return out;
      }
      if (x[i] < out[0]) {
        out[0] = x[i];
      }
    }
  }

  
  return out;
}
```

```{r}
minC(c(2:4, NA))
minC(c(2:4, NA), na_rm = TRUE)
```

<!-- HW: If you wanted to do more, I'd suggest a variation where you put the `na_rm` check inside the inner loop. You can discuss that's a bit slower but there's less duplicated code -->

__[Q2]{.Q}__: Rewrite `cumsum()` and `diff()` so they can handle missing values. Note that these functions have slightly more complicated behaviour.

__[A]{.solved}__: Our `NA`-aware `cumsumC()` function will return a vector of the same length as `x`. By default (`na_rm = false`) all values following the first `NA` input value will be set to `NA` also, because the cumulative here depends on the unknown missing value. In case of `na_rm = true` the `NA` values the missing input values will be treated like zeros.

<!-- TODO: Implement na_rm-flag with the behavior outlined above -->

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector cumsumC(NumericVector x) {
  int n = x.size();
  NumericVector out(n);
  LogicalVector is_missing = is_na(x);
  
  out[0] = x[0];
  for(int i = 1; i < n; ++i) {
    if (is_missing[i - 1]) {
      out[i] = NA_REAL;
    } else{
      out[i] = out[i - 1] + x[i];
    }
  }
  
  return out;
}
```

```{r}
cumsumC(c(1, NA, 2, 4))
# cumsumC(c(1, NA, 2, 4), na_rm = TRUE)
```

The `diffC()` implementation will return a single `NA` value, if the input vector contains a missing value. In case of `na_rm = true`, the function will return an `NA` for every difference with at least one `NA` as input.

<!-- TODO: consider returning a NA vector of length x for na_rm = FALSE, as this is more consistent with the above solution. -->

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector diffC(NumericVector x, int lag = 1,
                    bool na_rm = false){
  int n = x.size();
  NumericVector out(n - lag);
  for(int i = lag; i < n; i++){
    if (NumericVector::is_na(x[i]) ||
        NumericVector::is_na(x[i - lag])) {
      if (!na_rm) {
        return NumericVector::create(NA_REAL);
      }
      out[i - lag] = NA_REAL;
      continue;
    }
    out[i - lag] = x[i] - x[i - lag];
  }
  return out;
}
```

```{r}
diffC(c(1, 3, NA, 10))
diffC(c(1, 3, NA, 10), na_rm = TRUE)
```

## Standard Template Library

To practice using the STL algorithms and data structures, implement the following using R functions in C++, using the hints provided:

__[Q1]{.Q}__: `median.default()` using `partial_sort`.

__[A]{.solved}__: The median is computed differently for even or odd vectors, which we allow for in the function below.

```{Rcpp}
#include <algorithm>
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double medianC(NumericVector x) {
  int n = x.size();

  if (n % 2 == 0){
    std::partial_sort (x.begin(), x.begin() + n / 2 + 1, x.end());
    return (x[n / 2 - 1] + x[n / 2]) / 2;
  } else {
    std::partial_sort (x.begin(), x.begin() + (n + 1) / 2, x.end());
    return x[(n + 1) / 2 - 1];
  }
}
```

__[Q2]{.Q}__: `%in%` using `unordered_set` and the `find()` or `count()` methods.

__[A]{.solved}__: We use the `find()` method and loop through the `unordered_set` until we find a match or have scanned the entire set.

```{Rcpp, eval=FALSE}
#include <Rcpp.h>
#include <unordered_set>
using namespace Rcpp;

// [[Rcpp::export]]
LogicalVector inC(CharacterVector x, CharacterVector table) {
  std::unordered_set<String> seen;
  seen.insert(table.begin(), table.end());
  
  int n = x.size();
  LogicalVector out(n);
  for (int i = 0; i < n; ++i) {
    out[i] = seen.find(x[i]) != seen.end();
  }
  
  return out;
}
```

__[Q3]{.Q}__: `unique()` using an `unordered_set` (challenge: do it in one line!).

__[A]{.solved}__: The `insert()`-method will return if an equivalent element already existed. If a new element is inserted, we will add it to the (unique) return vector of our function.

```{Rcpp}
#include <Rcpp.h>
#include <unordered_set>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector uniqueC(NumericVector x) {
  std::unordered_set<int> seen;
  int n = x.size();
  
  std::vector<double> out;
  for (int i = 0; i < n; ++i) {
    if (seen.insert(x[i]).second) out.push_back(x[i]);
  }
  
  return wrap(out);
}


// As a one-liner
// [[Rcpp::export]]
std::unordered_set<double> uniqueCC(NumericVector x) {
  return std::unordered_set<double>(x.begin(), x.end());
}
```

__[Q4]{.Q}__: `min()` using `std::min()`, or `max()` using `std::max()`.

__[A]{.solved}__: We will implement `min()` by iterating over the vector and recursively comparing each element to the current minimum value.

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double minC(NumericVector x){
  int n = x.size();
  double out = x[0];
  
  for (int i = 0; i < n; i++){
    out = std::min(out, x[i]);
  }
  
  return out;
}
```

__[Q5]{.Q}__: `which.min()` using `min_element`, or `which.max()` using `max_element`.

__[A]{.solved}__: To implement `which.min()`, we will first locate the `min_element()` and then compute the `distance()` to it (from the beginning of the vector).

```{Rcpp}
#include <Rcpp.h>
#include <algorithm>
#include <iterator>
using namespace Rcpp;

// [[Rcpp::export]]
double which_minC(NumericVector x){
  int out = std::distance(
    x.begin(), std::min_element(x.begin(), x.end())
  );

  return out + 1;
}
```

__[Q6]{.Q}__: `setdiff()`, `union()`, and `intersect()` for integers using sorted ranges and `set_union`, `set_intersection` and `set_difference`.

__[A]{.solved}__: The structure of the three functions will be very similar.

We first sort both input vectors. Then we apply the respective `set_union`, `set_intersection` or `set_difference` function. After that, the result will be between the iterators `tmp.begin()` and `out_end`. To retrieve the result we loop once through the range between `tmp.begin()` and `out_end` in the last part of each function.

One note on the naming of the functions: `union` is a special class in cpp so we may not use it for our function definition and rather use `setunion`.

```{Rcpp}
#include <Rcpp.h>
#include <unordered_set>
#include <algorithm>
using namespace Rcpp;

// [[Rcpp::plugins(cpp11)]]
// [[Rcpp::export]]
IntegerVector setunion(IntegerVector x, IntegerVector y) {
  int nx = x.size();
  int ny = y.size();
  
  IntegerVector tmp(nx + ny);
  
  std::sort(x.begin(), x.end());
  std::sort(y.begin(), y.end());
  
  IntegerVector::iterator out_end = std::set_union(
    x.begin(), x.end(), y.begin(), y.end(), tmp.begin()
  );
  
  IntegerVector out;
  for(IntegerVector::iterator it = tmp.begin();
      it != out_end; ++it) {
    out.push_back(*it);
  }
  
  return out;
}

// [[Rcpp::export]]
IntegerVector intersect(IntegerVector x, IntegerVector y) {
  int nx = x.size();
  int ny = y.size();
  
  IntegerVector tmp(std::min(nx, ny));
  
  std::sort(x.begin(), x.end());
  std::sort(y.begin(), y.end());
  
  IntegerVector::iterator out_end = std::set_intersection(
    x.begin(), x.end(), y.begin(), y.end(), tmp.begin()
  );
  
  IntegerVector out;
  for(IntegerVector::iterator it = tmp.begin();
      it != out_end; ++it) {
    out.push_back(*it);
  }
  
  return out;
}

// [[Rcpp::export]]
IntegerVector setdiff(IntegerVector x, IntegerVector y) {
  int nx = x.size();
  int ny = y.size();
  
  IntegerVector tmp(nx);
  
  std::sort(x.begin(), x.end());
  std::sort(y.begin(), y.end());
  
  IntegerVector::iterator out_end = std::set_difference(
    x.begin(), x.end(), y.begin(), y.end(), tmp.begin()
  );
  
  IntegerVector out;
  for(IntegerVector::iterator it = tmp.begin();
      it != out_end; ++it) {
    out.push_back(*it);
  }
  
  return out;
}
```

Let's verify, that these functions work as intended.

```{r}
x <- c(1, 2, 3, 3)
y <- c(3, 2, 5)

setunion(x, y)
intersect(x, y)
setdiff(x, y)

typeof(setdiff(x, y))
```
