```{r, include=FALSE}
source("before_chapter.R")
```

# S3

## Basics

1. __<span style="color:red">Q</span>__: Describe the difference between `t.test()` and `t.data.frame()`? When is each function called?

   __<span style="color:green">A</span>__: Because of S3's `generic.class()` naming scheme, both functions may initially look similar, while they are in fact unrelated.
   
   - `t.test()` calls a *generic* function and will perform a t-test. 
   - The *method* `t.data.frame()` is called by the generic `t()` to transpose data frame input.

2. __<span style="color:red">Q</span>__: Make a list of commonly used base R functions that contain `.` in their name but are not S3 methods.

   __<span style="color:green">A</span>__: In the recent years "snake_case"-style has become increasingly common when naming functions (and variables) in R. But many functions in base R will continue to be "point.separated", which is why some inconsitency in your R code most likely cannot be avoided.
   
    ```{r, eval=FALSE}
    # some base R functions with point.separated names
    install.packages()
    read.csv()
    
    list.files()
    download.file()
    
    data.frame()
    as.character()
    Sys.Date()
    
    all.equal()
    
    do.call()
    on.exit()
    ```
   
   For some of these functions "tidyverse"-replacements may exist such as `readr::read_csv()` or `rlang::as_character()`, which you could use at the cost of an extra dependency.

<!-- possibly mention https://journal.r-project.org/archive/2012/RJ-2012-018/RJ-2012-018.pdf (The State of Naming Conventions in R)    -->

3. __<span style="color:red">Q</span>__: What does the `as.data.frame.data.frame()` method do? Why is it confusing? How could you avoid this confusion in your own code?

   __<span style="color:green">A</span>__: The function `as.data.frame.data.frame()` implements the data frame *method* for the `as.data.frame()` *generic*, which coerces objects to data frames.

   The name is confusing, because it does not clearly communicate the type of the function, which could be a regular function, a generic or a method. Even if we assume a method, the amount of `.`'s makes it difficult to seperate the generic- and the class-part of the name.  

   We could avoid this confusion by applying a different naming convention (e.g. "snake_case") for our class and function names.

4. __<span style="color:red">Q</span>__: Describe the difference in behaviour in these two calls.

    ```{r}
    set.seed(1014)
    some_days <- as.Date("2017-01-31") + sample(10, 5)
    
    mean(some_days)
    mean(unclass(some_days))
    ```
    
   __<span style="color:green">A</span>__: `mean()` is a generic function, which will select the appropriate method based on the class of the input. `some_days` has the class "Date" and `mean.Date(some_days)` will be used.
    
   After `unclass()` has removed the class attribute the default method is chosen by the methed dispatch. (`mean.default(unclass(some_days))`) calculates the mean of the underlying double.  
    
   <!-- When you look into the source code of `mean.Date()` (one line), you will see that the difference in the resulting objects is only the class attribute. -->
   <!-- I agree, that inspecting `mean.Date` is interesting, though I am not entirely sure, how the dots work here and how the origin of the date is passed to `.Date`. It looks to me, as if the result of `mean.default(unclass(x))` is then backtransformend into a Date... If we can describe this consicely, we can use it otherwise I think we can safely skip it. (HB, 2019-03-12) -->

5. __<span style="color:red">Q</span>__: What does the following code return? What base type is it built on? What attributes does it use?
    
    ```{r}
    x <- ecdf(rpois(100, 10))
    x
    ```
    
   __<span style="color:green">A</span>__: This code returns an object of the class "ecdf" and contains an empirical cumulative distribution function of its input. The object is built on the base type "closure" and the expression, which was used to create it (`rpois(100, 10)`) is stored in in the `call` attribute.

6. __<span style="color:red">Q</span>__: What does the following code return? What base type is it built on? What attributes does it use?
    
    ```{r}
    x <- table(rpois(100, 5))
    x
    ```

   __<span style="color:green">A</span>__: This code returns a "table" object, which is build upon the base type "integer". The attribute "dimnames" are used to name the elements of the integer vector.

## Classes

1. __<span style="color:red">Q</span>__: Write a constructor for `data.frame` objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?

   __<span style="color:green">A</span>__: Data frames are built on (named) lists with the additional requirement that all elements must have the same length. Their only attribute is "row.names". These must be unique, have the same length as each list element and also must be of integer or character type.
   
   There are no additional restrictions to column names apart to those of lists, so one could use special characters and surround the names with backticks (which is not recommended).
   
   A very good constructor implementing these criteria used to part of the sloop package. It is no longer part of the package, but the source can still be found online (https://github.com/r-lib/sloop/blob/be7ce8a6be660536df4bdd3a31fa54f0d627f2d6/R/data.frame.R#L11).
    
    ```{r, error=TRUE}
    # copied from older version of the sloop package
    new_data.frame <- function(x, row.names = NULL) {
      stopifnot(is.list(x))
      
      n <- if (length(x) == 0) 0 else length(x[[1]])
      lengths <- vapply(x, length, integer(1))
      stopifnot(all(lengths == n))
      
      if (is.null(row.names)) {
        row.names <- .set_row_names(n)
      } else {
        stopifnot(
          is.character(row.names) || 
            is.numeric(row.names)
          )
        stopifnot(
          length(row.names) == n || 
            length(row.names) == 2
          )
      }
      
      structure(
        x,
        class = "data.frame",
        row.names = row.names
      )
    }
    
    # Test
    x <- list(a = 1, b = 2)
    new_data.frame(x, row.names = "l1")
    new_data.frame(x, row.names = 1)
```
    
2. __<span style="color:red">Q</span>__: Enhance our `factor()` helper to have better behaviour when one or more `values` is not found in `levels`. What does `base::factor()` do in this situation?
    
   __<span style="color:green">A</span>__: `base::factor()` converts these values (silently) into `NA`'s. To improve our `factor()` helper we choose to return an informative error message instead.
    
    ```{r, eval = FALSE}
    factor <- function(x, levels = unique(x)) {
      new_levels <- match(x, levels)
      
      # return error if unseen levels are passed
      if(any(is.na(new_levels))){
        stop("The following values do not occur ",
             "in the levels of x: ",
             paste(setdiff(x, levels), collapse = ", ")
             ".", 
             call. = FALSE)
        }
      
      validate_factor(new_factor(new_levels, levels))
    }
    ```

3. __<span style="color:red">Q</span>__: Carefully read the source code of `factor()`. What does it do that our constructor does not?

   __<span style="color:green">A</span>__: The original implementation allows a more flexible specification of input for `x`. The input is coerced to character or replaced by `character(0)` (in case of `NULL`). It also ensured that the factor levels are unique. This is achieved by setting the levels via `base::levels<-`, which fails when duplicate values are supplied.

4. __<span style="color:red">Q</span>__: Factors have an optional “contrasts” attribute. Read the help for `C()`, briefly describe it’s purpose. Rewrite our `new_factor()` constructor to include this attribute.

   __<span style="color:green">A</span>__: When factor variables (representing nominal or ordinal information) are used in statistical models, they are typically encoded as dummy variables and by default each level is compared with the first factor level. But many other encodings ("contrasts") are possible: https://en.wikipedia.org/wiki/Contrast_(statistics)

   Within R's formula interface you can wrap a factor in `C` and specify the contrast of your choice. Alternativly you can set the "contrast" attribute of you factor variable, which accepts matrix input. (see `?contr.helmert` or similar for details)


    ```{r}
    # updated factor constructor
    new_factor <- function(
      x = integer(),
      levels = character(),
      contrast = NULL
    ) {
      stopifnot(is.integer(x))
      stopifnot(is.character(levels))
      stopifnot(is.matrix(contrast) | is.null(contrast))
      
      structure(
        x,
        levels = levels,
        class = "factor",
        contrast = contrast
      )
    }
    ```

5. __<span style="color:red">Q</span>__: Read the documentation for `utils::as.roman()`. How would you write a constructor? Does it need a validator? What would a helper look like?

   __<span style="color:green">A</span>__: This function transforms numeric input into roman numbers (how cool is this!). This class is built on the "integer" type, which results in the following constructor.

    ```{r}
    new_roman <- function(x = integer()){
      stopifnot(is.integer(x))
      structure(x, class = "roman")
    }
    ```

   The documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.

    ```{r}
    validate_roman <- function(x) {
      values <- unclass(x)
      
      if(any(values < 1 | values > 3899)) {
        stop(
          "Roman numbers are only defined between ",
          "1 and 3899.",
          call. = FALSE
        )
      }
      
      x
    }
```

   <!-- Anyone have an idea, why 3899 is the upper limit for roman numbers in R? -->

   For convenience, we allow the user to also pass real values to a helper function.

    ```{r, error=TRUE}
    roman <- function(x = integer()) {
      x <- as.integer(x)
      
      validate_roman(new_roman(x))
    }
    
    # Test
    roman(c(1, 753, 2019))
    roman(0)
    ```


## Generics and methods

1. __<span style="color:red">Q</span>__: Read the source code for `t()` and `t.test()` and confirm that `t.test()` is an S3 generic and not an S3 method. What happens if you create an object with class `test` and call `t()` with it? Why?
    
    ```{r}
    x <- structure(1:10, class = "test")
    t(x)
    ```
    
   __<span style="color:green">A</span>__: We can see that `t.test()` is a generic, because it calls `UseMethod()`
    
    ```{r}
    t.test
    ```  
    
   There are also other (programmatic) possibilities to check this like `pryr::ftype()`, which checks via its internal `pryr:::is_s3_generic`, which uses `codetools::findGlobals()` that `t.test()` contains a call to `UseMethod()`.
    
   Interestingly, while digging a bit around in the pryr package, one can also find some dependencies to the tools package, where a list of functions exists, which tells you about some functions that look like methods, but are not.
    
    ```{r}
    tools::nonS3methods("stats")
    ```
    
   However, if we create an object with class `test`, `t()`, will dispatch to `t.test()`. This simply happens, because `UseMethod()` just looks for functions named `paste0("generic", ".", c(class(x), "default"))`. So `t.test()` is erroneously treated like a method of `t()`. Since `t.test()` is a generic itself and doesn't find a method called `t.test.test()`, it dispatches to `t.test.default()`. Just to proof the latter quickly, we specify a method `t.test.test()` and see what happens:
    
    ```{r}
    t.test.test <- function(x) t.default(x)
    t(x)
    ```

2. __<span style="color:red">Q</span>__: Which base generic has the greatest number of defined methods?
    
   __<span style="color:green">A</span>__: `print()` has clearly the most
    
    ```{r}
    library(methods)
    objs <- mget(ls("package:base"), inherits = TRUE)
    funs <- Filter(is.function, objs)
    generics <- Filter(function(x) ("generic" %in% pryr::ftype(x)), funs)
    
    sort(
      lengths(sapply(names(generics), function(x) methods(x), USE.NAMES = TRUE)),
      decreasing = TRUE
      )[1:3]
    ```

3. __<span style="color:red">Q</span>__: The table() function produces output with class “table”. What attributes does this class possess? What generics does it have methods for?

   __<span style="color:green">A</span>__: 

4. __<span style="color:red">Q</span>__: Carefully read the documentation for `UseMethod()` and explain why the following code returns the results that it does. What two usual rules of function evaluation does `UseMethod()` violate?
    
    ```{r}
    g <- function(x) {
      x <- 10
      y <- 10
      UseMethod("g")
    }
    g.default <- function(x) c(x = x, y = y)
    
    x <- 1
    y <- 1
    g(x)
    ```
    
   __<span style="color:green">A</span>__: R looks for the `x` argument in `g()`'s calling environment (the global environment), where `x` is defined as 1. Then `g()` dispatches to `g.default()`. The `x` argument is given to `g.default()`. `y` is not defined inside it, so `g.default()` takes `y`'s value from the environment where `UseMethod()` created the call. There `y` is defined as 10.  
    
   `UseMethod()` behaves special in many ways, two of them are:
    
   * it never "returns" (any statement after `UseMethod` won't be evaluated)
   * the argument matching can become a bit tricky (generic and methods should have the same order of arguments or you must name them)
    
    ```{r}
    g <- function(x, y) {UseMethod("g")}
    g.default <- function(y, x) c(x = x, y = y)
    
    g(10, 100)
    g(x = 10, y = 100)
    ```
    
5. __<span style="color:red">Q</span>__: What are the arguments to `[`? Why is this a hard question to answer?

   __<span style="color:green">A</span>__: 
    
## Object styles

1. __<span style="color:red">Q</span>__: Categorise the objects returned by `lm()`, `factor()`, `table()`, `as.Date()`, `ecdf()`, `ordered()`, `I()` into "vector", "scalar", and "other".
    
   __<span style="color:green">A</span>__: 
    
   vector: `factor()`, `table()`, `as.Date()`, `ordered()`  
   scalar: `lm()`  
   other: `ecdf()`, `I()`  
    
2. __<span style="color:red">Q</span>__: What would a constructor function for `lm` objects, `new_lm()`, look like?
    Why is a constructor function less useful for linear models? (Think about what functions would call `new_lm()`.)
    
   __<span style="color:orange">A</span>__: TODO: 2nd part of the question.
    
    ```{r}
    new_lm <- function(coefficiets, residuals, effects, rank, fitted.values, assign,
                       qr, df.residual, xlevels, call, terms, model) {
      
      stopifnot(is.double(coefficients), is.double(residuals), is.double(effects),
                is.integer(rank), is.double(fitted.values), is.integer(assign),
                is.list(qr), is.integer(df.residual), is.list(xlevels),
                is.language(call), is.language(terms), is.list(model))
      
      structure(
        list(
          coefficients = coefficients,
          residuals = residuals,
          effects = effects,
          rank = rank, 
          fitted.values = fitted.values,
          assign = assign,
          qr = qr,
          df.residual = df.residual,
          xlevels = xlevels,
          call = call,
          terms = terms, 
          model = model
          ),
        class = "lm"
      )
      }
    ```

## Inheritance

1. __<span style="color:red">Q</span>__: The `ordered` class is a subclass of `factor`, but it's implemented in a very ad hoc way in base R. Implement it in a principled way by building a constructor and providing `vec_restore()` method.
    
    ```{r}
    f1 <- factor("a", c("a", "b"))
    as.factor(f1)  
    as.ordered(f1) # loses levels
    ```

   __<span style="color:orange">A</span>__: TODO: the olad exercise text ended on "an `as_ordered` generic". Check the answer if it needs to be updated.
    
   ordered is a subclass of factor, so we need to do the following
    
   * for factors: add a subclass argument to the constructor and helper
   * for ordered: add a constructor
   * write an `as_ordered()` generic with methods ordered, factor and default
    
   We use the **factor** constructor from the textbook and add the subclass argument
    
    ```{r}
    new_factor <- function(x, levels, ..., subclass = NULL) {
      stopifnot(is.integer(x))
      stopifnot(is.character(levels))
      
      structure(
        x,
        levels = levels,
        class = c(subclass, "factor")
      )
    }
    ```
    
   We also use the validator for factors from the textbook
    
    ```{r}
    validate_factor <- function(x) {
      values <- unclass(x)
      levels <- attr(x, "levels")
      
      if (!all(!is.na(values) & values > 0)) {
        stop(
          "All `x` values must be non-missing and greater than zero",
          call. = FALSE
        )
      }
      
      if (length(levels) < max(values)) {
        stop(
          "There must at least as many `levels` as possible values in `x`",
          call. = FALSE
        )
      }
      
      x
    }
    ```
    
   And we add the subclass argument for the helper from the textbook and the exercises
    
    ```{r}
    factor <- function(x, levels = unique(x), ... , subclass = NULL) {
      ind <- match(x, levels)
      
      # error when values occur, which are not in the levels
      if(any(is.na(ind))){
        stop("The following values do not occur in the levels: ",
             paste(setdiff(x,levels), collapse = ", "), ".", 
             call. = FALSE)
        }
      
      validate_factor(new_factor(ind, levels, subclass = subclass))
    }
    ```
    
   A constructor for ordered is already implemented in the sloop package:
    
    ```{r}
    new_ordered <- function (x, levels) {
      stopifnot(is.integer(x))
      stopifnot(is.character(levels))
      structure(x, levels = levels, class = c("ordered", "factor"))
    }
    ```
    
   The implementation of the **generic** and the first two methods is straight forward
    
    ```{r}
    as_ordered <- function(x, ...) {
      UseMethod("as_ordered")
    }
    
    as_ordered.ordered <- function(x, ...) x
    as_ordered.default <- function(x, ...) {
      stop(
        "Don't know how to coerce object of class ", 
        paste(class(x), collapse = "/"), " into an ordered factor", 
        call. = FALSE
      )
    }
    ```
    
   For the factor method of `as_ordered()` we use the factor helper, since it saves us some typing:
    
    ```{r}
    as_ordered.factor <- function(x, ...) {
      factor(x, attr(x, "levels"), subclass = "ordered")
    }
    ```
    
   Finally, our new method preserves all levels:
    
    ```{r}
    as_ordered(f1)
    ```
    
   For a real scenario, we might want to add an `as_factor.ordered()` method to the `as_factor()` generic from the textbook.

2. __<span style="color:red">Q</span>__: How does `[.Date` support subclasses? How does it fail to support subclasses?

   __<span style="color:green">A</span>__: 

3. __<span style="color:red">Q</span>__: R has two classes for representing date time data, `POSIXct` and `POSIXlt`, which both inherit from `POSIXt`. Which generics have different behaviours for the two classes? Which generics share the same behaviour?
    
   __<span style="color:green">A</span>__: To answer this question, we have to get the regarding generics
    
    ```{r}
    # generics of POSIXt
    generics_t <- attr(methods(class = "POSIXt"), "info")[["generic"]]
    # Generics of POSIXct
    generics_ct <- attr(methods(class = "POSIXct"), "info")[["generic"]]
    # generics of POSIXlt
    generics_lt <- attr(methods(class = "POSIXlt"), "info")[["generic"]]
    ```
    
   Those generics that have a method for POSIXt are potentially sharing the same behaviour (`generics_t`). However, those generics that have a specific method for one of the sublcases have to be subtractet:
    
    ```{r}
    generics_same <- setdiff(generics_t, union(generics_ct, generics_lt))
    generics_same
    ```
    
   The rest is different
    
    ```{r}
    generics_different <- union(generics_ct, generics_lt)
    generics_different
    ```

4. __<span style="color:red">Q</span>__: What do you expect this code to return? What does it actually return? Why?

    ```{r, eval = FALSE}
    generic2 <- function(x) UseMethod("generic2")
    generic2.a1 <- function(x) "a1"
    generic2.a2 <- function(x) "a2"
    generic2.b <- function(x) {
      class(x) <- "a1"
      NextMethod()
    }
    
    generic2(sloop::new_s3_scalar(class = c("b", "a2")))
    ```
    
   __<span style="color:orange">A</span>__: TODO: Question text changed from "Explain what is happening in the following code."...So check, if the answer needs to be updated accordingly. Also set eval to true in the code chunk and check why new_s3_scalar is not found (maybe wrong sloop version?).
    
   * We supply an object of classes `b` and `a2` to `generic2()`, so R will look for a method`generic2.b()`
   * `generic2.b()` changes the class to `a1` and then calls `NextMethod()`
   * One could think, that R calls now`generic2.a1()`. But in fact, as mentioned
    in the textbook, `NextMethod()` 
    
        > doesn’t actually work with the class attribute of the object, but instead uses a special global variable (.Class) to keep track of which method to call next.

   * We can easily verify (for example via `print()`) that `.Class` is still `c("b", "a2")` and so `generic2.a2()` gets called.

## Dispatch details

1. __<span style="color:red">Q</span>__: Explain the differences in dispatch below:

    ```{r}
    x1 <- 1:5
    class(x1)
    sloop::s3_dispatch(x1[1])
    
    x2 <- structure(x1, class = "integer")
    class(x2)
    sloop::s3_dispatch(x2[1])
    ```

   __<span style="color:green">A</span>__: 

2.  __<span style="color:red">Q</span>__: What classes have a method for the `Math` group generic in base R? Read the source code. How do the methods work?

   __<span style="color:green">A</span>__: The following functions belong to this group (see ?`Math`):
    
   * abs, sign, sqrt, floor, ceiling, trunc, round, signif
   * exp, log, expm1, log1p, cos, sin, tan, cospi, sinpi, tanpi, acos, asin, atan, cosh, sinh, tanh, acosh, asinh, atanh
   * lgamma, gamma, digamma, trigamma
   * cumsum, cumprod, cummax, cummin
    
    The following classes have a method for this group generic:
    
    ```{r}
    methods("Math")
    ```
    
    To read the source code of the S3 classes, we can just enter the name of the method into the console. To get the source code of the S4 classes, we can use `getMethod()`, i. e. `getMethod("Math", "nonStructure")`.
    
    To explain the basic idea, we just overwrite the data frame method:
    
    ```{r}
    Math.data.frame <- function(x){"hello"}
    ```
    
    Now all functions from the math generic group, will return `"hello"`
    
    ```{r}
    abs(iris)
    exp(iris)
    lgamma(iris)
    ```
    
    So, I hope the idea is clear. However, of course different functions should perform different calculations. Here `.Generic` comes into play, which provides us the calling generic as a string

    ```{r}
    Math.data.frame <- function(x, ...){
      .Generic
    }
    
    abs(iris)
    exp(iris)
    lgamma(iris)
    
    rm(Math.data.frame)
    ```
    
    `Math.data.frame()` is a good example, how to invoke `.Generic` to build sth. constructive up on `.Generic`. `Math.factor()` is a good example of a method, which is simply defined for better error messages.

3.  __<span style="color:red">Q</span>__: `Math.difftime()` is more complicated than I described. Why?

    __<span style="color:green">A</span>__: `Math.difftime()` needs to exclude other cases than abs, sign, floor, ceiling, trunc, round and signif and supply an according error message.

## Old exercises

1. __<span style="color:red">Q</span>__: The most important S3 objects in base R are factors, data frames, difftimes, and date/times (Dates, POSIXct, POSIXlt). You've already seen the attributes and base type that factors are built on. What base types and attributes are the others built on?
    
   __<span style="color:orange">A</span>__: TODO: Add answer for difftime.
    
   **data frame:** Data frames are build up on (named) lists. Together with the `row.names` attribute and after setting the class to "data.frame", we get a classical data frame
    
    ```{r}
    df_build <- structure(list(1:2, 3:4),
                          names = c("a", "b"),
                          row.names = 1:2, 
                          class = "data.frame")
    
    df_classic <- data.frame(a = 1:2, b = 3:4)
    
    identical(df_build, df_classic)
    ```
    
   **date/times (Dates, POSIXct, POSIXlt):** Date is just a double with the class attribute set to "Date"
    
    ```{r}
    date_build <- structure(0, class = "Date")
    date_classic <- as.Date("1970-01-01")
    identical(date_build, date_classic)
    ```
    
   POSIXct is a class for date/times that inherits from POSIXt and is built on doubles as well. The only attribute is tz (for timezone)
    
    ```{r}
    POSIXct_build <- structure(1, class = c("POSIXct", "POSIXt"), tzone = "CET")
    POSIXct_classic <- .POSIXct(1, tz = "CET") # note that tz's default is NULL
    identical(POSIXct_build, POSIXct_classic)
    ```
    
   POSIXlt is another date/time class that inherits from POSIXt. It is built on top of a named list and a tzone attribute. Differences between POSIXct and POSIXlt are described in `?DateTimeClasses`.
    
    ```{r}
    POSIXlt_build <- structure(list(sec = 30,
                                    min = 30L,
                                    hour = 14L,
                                    mday = 1L,
                                    mon = 0L,
                                    year = 70L,
                                    wday = 4L,
                                    yday = 0L,
                                    isdst = 0L,
                                    zone = "CET",
                                    gmtoff = 3600L),
                               tzone = c("", "CET", "CEST"),
                               class = c("POSIXlt", "POSIXt"))
    POSIXlt_classic <- as.POSIXlt(.POSIXct(13.5 * 3600 + 30))
    identical(POSIXlt_build, POSIXlt_classic)
    ```

1.  __<span style="color:red">Q</span>__: Draw a Venn diagram illustrating the relationships between functions, generics, and methods.
    
    __<span style="color:orange">A</span>__: Funtions don't have to be generics or methods, but both the latter are functions. It is also possible that a function is both, a method and a generic, at the same time, which seems to be relatively awkward, so that also the author of the textbook doesn't recommend it, see `?pryr::ftype`

    > This function figures out whether the input function is a regular/primitive/internal function, a internal/S3/S4 generic, or a S3/S4/RC method. This is function is slightly simplified as it's possible for a method from one class to be a generic for another class, but that seems like such a bad idea that hopefully no one has done it.

2.  __<span style="color:red">Q</span>__: Write a constructor for `difftime` objects. What base type are they built on? What attributes do they use? You'll need to consult the documentation, read some code, and perform some experiments.
    
    __<span style="color:green">A</span>__: Our constructor should be named `new_class_name`, have one argument for its base type and each attribute and check the base types of these arguments as well. 
    
    ```{r}
    new_difftime <- function(x, units = "auto") {
      stopifnot(is.double(x), is.character(units))
      
      structure(x, units = units, class = "difftime")
    }
    ```
    
    However, since the following result prints awkward
    
    ```{r}
    new_difftime(3)
    ```
    
    we get a little bit more "inspiration" by the original `difftime()` function and make the regarding changes. Basically we need to implement logic for the units attribute, in case it is set to `"auto"` and convert the value of the underlying double from seconds to the regarding unit, as commented in the following
    
    ```{r}
    new_difftime <- function(x, units = "auto") {
      stopifnot(is.double(x), is.character(units))
      
      # case units == "auto":
      if (units == "auto") 
        # when all time differences are NA, units should be "secs"
        units <- if (all(is.na(x))){
          "secs"
        } else {
          # otherwise set the units regarding to the minimal time difference
          x_min <- min(abs(x), na.rm = TRUE)
          if (!is.finite(x_min) || x_min < 60) {
            "secs"
          } else if (x_min < 3600) {
            "mins"
          } else if (x_min < 86400) {
            "hours"
          } else {
            "days"
          }
        }
      
      # we rescale the underlying double, according to the units
      x <- switch(units, 
                  secs = x,
                  mins = x/60,
                  hours = x/3600,
                  days = x/86400,
                  weeks = x/(7 * 86400))
      
      structure(x, units = units, class = "difftime")
    }
    
    # test
    new_difftime(c(NA, -3600, 86400))
    ```
