# Function operators

## Behavioural FOs

1.  __<span style="color:red">Q</span>__: Write a FO that logs a time stamp and message to a file every time a 
    function is run.
    
    __<span style="color:green">A</span>__: Note that the example will create a file file in your current working directory:
    
    ```{r, eval = FALSE}
    logger <- function(f, filename){
      force(f)
      filename_tmp <- paste(filename, basename(tempfile()), sep = "_")
      write(paste("created at:", Sys.time()), filename_tmp, append = TRUE)
      function(..., message = "you can add a message at each call") {
        write(paste0("used at: ", Sys.time(), ", ", message), filename_tmp, append = TRUE)
        f(...)
      }
    }
    
    # the following line creates a file, which name starts with "mean_log_"
    mean2 <- logger(mean, "mean_log") 
    mean2(1:4, message = "first time") 
    mean2(1:4, message = "second_time")
    ```

2.  __<span style="color:red">Q</span>__: What does the following function do? What would be a good name for it?

    ```{r}
    f <- function(g) {
      force(g)
      result <- NULL
      function(...) {
        if (is.null(result)) {
          result <<- g(...)
        }
        result
      }
    }
    runif2 <- f(runif)
    runif2(5)
    runif2(10)
    ```

3.  __<span style="color:red">Q</span>__: Modify `delay_by()` so that instead of delaying by a fixed amount of time, 
    it ensures that a certain amount of time has elapsed since the function 
    was last called. That is, if you called 
    `g <- delay_by(1, f); g(); Sys.sleep(2); g()` there shouldn't be an 
    extra delay.

4.  __<span style="color:red">Q</span>__: Write `wait_until()` which delays execution until a specific time.

5.  __<span style="color:red">Q</span>__: There are three places we could have added a memoise call: why did we 
    choose the one we did?

    ```{r, eval = FALSE}
    download <- memoise(dot_every(10, delay_by(1, download_file)))
    download <- dot_every(10, memoise(delay_by(1, download_file)))
    download <- dot_every(10, delay_by(1, memoise(download_file)))
    ```

6.  __<span style="color:red">Q</span>__: Why is the `remember()` function inefficient? How could you implement it 
    in more efficient way?

7.  __<span style="color:red">Q</span>__: Why does the following code, from 
    [stackoverflow](http://stackoverflow.com/questions/8440675), not do what you expect?

    ```{r}
    # return a linear function with slope a and intercept b.
    f <- function(a, b) function(x) a * x + b

    # create a list of functions with different parameters.
    fs <- Map(f, a = c(0, 1), b = c(0, 1))

    fs[[1]](3)
    # should return 0 * 3 + 0 = 0
    ```

    How can you modify `f` so that it works correctly?

## Output FOs

1.  __<span style="color:red">Q</span>__: Create a `negative()` FO that flips the sign of the output of the 
    function to which it is applied.

2.  __<span style="color:red">Q</span>__: The `evaluate` package makes it easy to capture all the outputs (results, 
    text, messages, warnings, errors, and plots) from an expression. Create a 
    function like `capture_it()` that also captures the warnings and errors 
    generated by a function.

3.  __<span style="color:red">Q</span>__: Create a FO that tracks files created or deleted in the working directory 
    (Hint: use `dir()` and `setdiff()`.) What other global effects of 
    functions might you want to track?

## Input FOs

1.  __<span style="color:red">Q</span>__: Our previous `download()` function only downloads a single file. How can 
    you use `partial()` and `lapply()` to create a function that downloads 
    multiple files at once? What are the pros and cons of using `partial()` vs. 
    writing a function by hand?

2.  __<span style="color:red">Q</span>__: Read the source code for `plyr::colwise()`. How does the code work? What 
    are `colwise()`'s three main tasks? How could you make `colwise()` simpler 
    by implementing each task as a function operator? (Hint: think about 
    `partial()`.)

3.  __<span style="color:red">Q</span>__: Write FOs that convert a function to return a matrix instead of a data 
    frame, or a data frame instead of a matrix. If you understand S3, 
    call them `as.data.frame.function()` and `as.matrix.function()`.

4.  __<span style="color:red">Q</span>__: You've seen five functions that modify a function to change its output 
    from one form to another. What are they? Draw a table of the various 
    combinations of types of outputs: what should go in the rows and what 
    should go in the columns? What function operators might you want to write 
    to fill in the missing cells? Come up with example use cases.

5.  __<span style="color:red">Q</span>__: Look at all the examples of using an anonymous function to partially 
    apply a function in this and the previous chapter. Replace the anonymous 
    function with `partial()`. What do you think of the result? Is it easier or 
    harder to read?

## Combining FOs

1.  __<span style="color:red">Q</span>__: Implement your own version of `compose()` using `Reduce` and `%o%`. For 
    bonus points, do it without calling `function`.

2.  __<span style="color:red">Q</span>__: Extend `and()` and `or()` to deal with any number of input functions. Can 
    you do it with `Reduce()`? Can you keep them lazy (e.g., for `and()`, the 
    function returns once it sees the first `FALSE`)?

3.  __<span style="color:red">Q</span>__: Implement the `xor()` binary operator. Implement it using the existing 
    `xor()` function. Implement it as a combination of `and()` and `or()`. What 
    are the advantages and disadvantages of each approach? Also think about 
    what you'll call the resulting function to avoid a clash with the existing
    `xor()` function, and how you might change the names of `and()`, `not()`, 
    and `or()` to keep them consistent.

4.  __<span style="color:red">Q</span>__: Above, we implemented boolean algebra for functions that return a logical 
    function. Implement elementary algebra (`plus()`, `minus()`, `multiply()`, 
    `divide()`, `exponentiate()`, `log()`) for functions that return numeric 
    vectors.