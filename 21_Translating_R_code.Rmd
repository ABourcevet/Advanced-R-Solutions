```{r, include=FALSE}
source("common.R")
```

# Translating R code

```{r setup}
library(rlang)
library(purrr)
```


## HTML

1. __[Q]{.Q}__: The escaping rules for `<script>` tags are different because they contain JavaScript, not HTML. Instead of escaping angle brackets or ampersands, you need to escape `</script>` so that the tag isn't closed too early. For example, `script("'</script>'")`, shouldn't generate this:

    ```html
    <script>'</script>'</script>
    ```
   
   But

    ```html
    <script>'<\/script>'</script>
    ```

   Adapt the `escape()` to follow these rules when a new argument `script` is set to `TRUE`.

   __[A]{.solved}__: To solve this exercise we first recreate the required functions from the book chapter. We then confirm that our code reliably escapes for tags like `<p>` and `<b>`, but doesn't escape correctly for the `<script>` tag. Next, we modify the `escape()` and `tag()` function to redefine the `<script>` tag. Finally we confirm that all defined tags now escape correctly.
   
   Note that `<style>` tags encapsulate css-styling guidelines and the escaping follows the same rules as the `<script>` tag does. We therefore add the same behaviour also for the `<style>` tag function.
   
   Let's run the required code from Advanced R first:

    ```{r required code from advr, include=TRUE}
    # Escaping
    html <- function(x) structure(x, class = "advr_html")
    
    print.advr_html <- function(x, ...) {
      out <- paste0("<HTML> ", x)
      cat(paste(strwrap(out), collapse = "\n"), "\n", sep = "")
    }
    
    escape <- function(x) UseMethod("escape")
    
    escape.character <- function(x) {
      x <- gsub("&", "&amp;", x)
      x <- gsub("<", "&lt;", x)
      x <- gsub(">", "&gt;", x)
      
      html(x)
    }
    
    escape.advr_html <- function(x) x
    
    # Basic tag functions
    dots_partition <- function(...) {
      dots <- list2(...)
      
      if (is.null(names(dots))) {
        is_named <- rep(FALSE, length(dots))
      } else {
        is_named <- names(dots) != ""
      }
      
      list(
        named = dots[is_named],
        unnamed = dots[!is_named]
      )
    }
    
    # html_attributes() function from the GitHub repository of Advanced R
    # https://github.com/hadley/adv-r/blob/master/dsl-html-attributes.r

    html_attributes <- function(list) {
      if (length(list) == 0) return("")
      
      attr <- map2_chr(names(list), list, html_attribute)
      paste0(" ", unlist(attr), collapse = "")
    }
    
    html_attribute <- function(name, value = NULL) {
      if (length(value) == 0) return(name) # for attributes with no value
      if (length(value) != 1) stop("`value` must be NULL or length 1")
      if (is.logical(value)) {
        # Convert T and F to true and false
        value <- tolower(value)
        } else {
          value <- escape_attr(value)
        }
      paste0(name, "='", value, "'")
    }
    
    escape_attr <- function(x) {
      x <- escape.character(x)
      x <- gsub("\'", '&#39;', x)
      x <- gsub("\"", '&quot;', x)
      x <- gsub("\r", '&#13;', x)
      x <- gsub("\n", '&#10;', x)
      x
    }
    
    # Tag functions
    tag <- function(tag) {
      new_function(
        exprs(... = ),
        expr({
          dots <- dots_partition(...)
          attribs <- html_attributes(dots$named)
          children <- map_chr(dots$unnamed, escape)
          
          html(paste0(
            !!paste0("<", tag), attribs, ">",
            paste(children, collapse = ""),
            !!paste0("</", tag, ">")
            ))
          }),
        caller_env()
      )
    }
    ```
    
   We confirm correct escaping for the `<p>` and `<b>` tag functions and incorrect escaping for the `<script>` tag function:
    
    ```{r}
    p <- tag("p")
    b <- tag("b")
    
    identical(p("This &","this <content>",
                b("& this will be escaped")) %>%
                as.character(),
              "<p>This &amp;this &lt;content&gt;<b>&amp; this will be escaped</b></p>")
    
    script <- tag("script")
    
    identical(script(
      "These signs will not be escaped: &, <, >, ", "but these ones will: </script> or </style>") %>% as.character(),
      "<script>These signs will not be escaped: &, <, >, but these ones will: <\\/script> or <\\/style></script>")
    ```

   Therefore, we modify the `escape()` and the `tag()` function by adding the argument `script=FALSE`. Note that we need to add this argument for all methods of the `escape()` generic.
   
    ```{r}
    escape <- function(x, script = FALSE) UseMethod("escape")
    
    escape.character <- function(x, script = script) {
      
      if (!script) {
        x <- gsub("&", "&amp;", x)
        x <- gsub("<", "&lt;", x)
        x <- gsub(">", "&gt;", x)
      }
      
      if (script) {
        x <- gsub("</script>", "<\\/script>", x, fixed = TRUE)
        x <- gsub("</style>",  "<\\/style>",  x, fixed = TRUE)
      }
      
      html(x)
    }
    
    escape.advr_html <- function(x, ...) x
    
    tag <- function(tag, script = FALSE) {
      
      new_function(
        exprs(... = ),
        expr({
          dots <- dots_partition(...)
          attribs <- html_attributes(dots$named)
          children <- map_chr(dots$unnamed,
                              # choose the escaping
                              ~ escape(., script = !!script))
          html(paste0(
          !!paste0("<", tag), attribs, ">",
          paste(children, collapse = ""),
          !!paste0("</", tag, ">")
          ))
          }),
        caller_env()
      )
    }
    ```
    
   Finally we create new `<p>`, `<b>` and `<script>` tag functions, which all pass their escaping tests now.
   
    ```{r}
    p <- tag("p")
    b <- tag("b")
    
    identical(p("This &","this <content>",
                b("& this will be escaped")) %>%
                as.character(),
              "<p>This &amp;this &lt;content&gt;<b>&amp; this will be escaped</b></p>")
    
    script <- tag("script", script = TRUE)
    style  <- tag("style" , script = TRUE)
    
    identical(script(
      "These signs will not be escaped: &, <, >, ", "but these ones will: </script> or </style>") %>% as.character(),
      "<script>These signs will not be escaped: &, <, >, but these ones will: <\\/script> or <\\/style></script>")
      
    script("These signs will not be escaped: &, <, >, ", "but these ones will: </script> or </style>")
    ```

2. __[Q]{.Q}__: The use of `...` for all functions has some big downsides. There's no input validation and there will be little information in the documentation or autocomplete about how they are used in the function. Create a new function that, when given a named list of tags and their attribute names (like below), creates tag functions with named arguments.

    ```{r, eval = FALSE}
    list(
      a = c("href"),
      img = c("src", "width", "height")
    )
    ```

   All tags should get `class` and `id` attributes.
    
   __[A]{.started}__: The use of `...` for all functions seems too general. It is known which attributes each tag function may have, so we can organize them in a named list of tags and attribute names.
    
   We now need to create tag functions where these attributes are prespecified as arguments. This will enable *autocompletion* and *input validation*. (Documentation would require the functions to be bundeled as a package which we won't do here.)
    
   Let's start by programmatically creating one tag function now and worry about the iteration problem later.
    
    ```{r}
    tag_info <- list(a = c("href", "src"))
    ```
    
   The function factory needs to be changed: We need to parse the information provided by the list (tag name and arguments) and unquote-splice the provided arguments into the args part of `rlang::new_function()`. This will provide the autocompletion. In this step we also add the global attributes class and id. 
    
   The values of the provided named attributes need to be collected, when the function is called. We use a little "environment-hack" to accomplish this. 
    
    ```{r}
    tag <- function(tag_i,
                    attr,
                    escape_choice = c("content", "script_or_style")
                    ) {
      # check list-input
      if (length(tag_info) != 1) {
        stop("Please provide information for just one function.")
      }
      
      tag <- enquo(tag_i)
      # split tag and attribute information
      # tag <- names(tag_info)
      # attr <- purrr::flatten_chr(tag_info)
      # prepare attributes
      attr_list <- rep(list(missing_arg()), length(attr))
      names(attr_list) <- attr
      
      escape_choice <- match.arg(escape_choice)
      
      new_function(
        # unquote splice into fixed arguments
        exprs(... = , class = , id = , !!!attr_list),
        expr({
          attribs <- caller_env(0) %>%  # TODO: possibly encapsulate this
            as.list() %>% 
            Filter(function(x) !is.symbol(x), .) %>% 
              html_attributes()
          dots <- validate_dots(...)
          
          children <- map_chr(dots$unnamed,
                              # choose the escaping
                              ~ escape(., escape_choice = !!escape_choice))
          
          html(paste0(
            # TODO: check !!tag, may be clearer!
            !!paste0("<", tag), attribs, ">",
            paste(children, collapse = ""),
            !!paste0("</", tag, ">")
            ))
          }),
        
        caller_env()
      )
    }
    ```
    
<!-- HW: to generate attribs I thnk you'd be better off doing something like this. Note that the defaults need to be NULL so that the user isn't forced to rely on them, and then we can eliminate the use of validate_dots() because we're taking a different approach.
 -->
 
```{r}
tag <- "img"
tag_attrs <- c("src", "width", "height")
attrs <- c("class", "id", tag_attrs)

attr_args <- map(set_names(attrs), ~ NULL)
attr_list <- call2("list", !!!syms(set_names(attrs)))

new_function(
  exprs(... = , !!!attr_args),
  expr({
    ellipsis::check_dots_unnamed() # cheat by using new package
    
    attribs <- !!attr_list
    dots <- compact(list(...))

    children <- map_chr(dots$unnamed, escape)
    html(paste0(
      !!paste0("<", tag), attribs, ">",
      paste(children, collapse = ""),
      !!paste0("</", tag, ">")
    ))
  })
)
```
 
    
   We also rewrite `validate_dots`. We check for any unexpected named arguments, which will serve as input validation. The list of unnamed arguments will be escaped as before.
    
    ```{r}
    validate_dots <- function(...) {
      dots <- dots_list(...)
      # Input validation
      if (any(have_name(dots))) { # names(dots) != ""
        stop("Unexpected named argument found.")
      }
      
      list(unnamed = dots)
    }
    ```

   A few comments regarding the implementation details: The `...` had to be placed in front of the other arguments - otherwise positional matching would assign unnamed values to prespecified values and and unnamed content wouldn't be recognized properly. It was also a challenges to properly collect the prespecified arguments. These are prespecified but setting them at runtime is optional, so they had to be collected in a lazy fashion. Our hack via `caller_env()` isn't pretty and could certainly be improved upon - but it works, as we can see here:
    
    ```{r, error=TRUE}
    # create a single tag function
    a <- tag(list(a = "href"))
    
    # all the general and specific arguments exist, so autocompletion will work
    formals(a)
    
    # named arguments are attributes, content is escaped properly
    a(class = "anchor", id = "a-1", 
      href = "http://somelink.com", "take a look at this & this")
    
    # not all named arguments need to be used
    a(href = "http://somelink.com", "take a look at this")
    
    # unspecified named arguments will throw an error
    a(href = "http://somelink.com", "take a look at this", width = "200")
    ```
    
   To create many tag functions we can iterate over a list with inputs.
    
    ```{r}
    tag_inputs <- list(
      a = c("href"),
      img = c("src", "width", "height"),
      body = NULL,
      h1 = NULL,
      b = NULL,
      p = NULL
    )
    # FIX required
    
    # TODO: created functions not fully correct, somehow attribs is written into the tag function instead of the tag-name
    
    # structure of the map/list structure not correct yet
    html_tags <- tag_inputs %>% 
      map(~ tag)  # potentially use imap to operate on index as well
    ```

3. __[Q]{.Q}__: Reason about the following code that calls `with_html()` referening objects from the environment. Will it work or fail? Why? Run the code to verify your predictions.
       
    ```{r, eval = FALSE}
    greeting <- "Hello!"
    with_html(p(greeting))
    
    address <- "123 anywhere street"
    with_html(p(address))
    ```
    
   __[A]{.started}__: (TODO: In the exercise the definition of `p` changed into `p <- function() "p"`. This needs to be added and the exercise/answer might need to get updated. Further `with_html` is defined in the next exercise. Therefore, a change to introduce it already here has to be made...and the chunks then need to be changed to `eval = TRUE`) When we created the various HTML tag functions, `address()` was one of them. This HTML tag may be used to provide contact information on an HTML page. All our tag functions are not present in the global environment, but rather elements of the list `html_tags`.
    
   The DSL code wrapped in `with_html()` is evaluated in its own environment and in the "context" of `html_tags`. The tag functions are available, because we provided a list of them as a data mask. As `r ?as_data_mask` indicates: "Objects in the mask have precedence over objects in the environment."
    
    ```{r, error=TRUE, eval = FALSE}
    greeting <- "Hello!"
    with_html(p(greeting))
    
    address <- "123 anywhere street"
    with_html(p(address))
    ```
    
   The error message then tells us, what the problem is: `p(address)` operates on `address()`, the function not the character, and we haven't implemented an `escape.function()` method. 
    
    ```{r, eval = FALSE}
    # checking our list of tag functions
    c("greeting", "address") %in% names(html_tags)
    
    # this works
    html_tags$address <- "123 anywhere street"
    
    with_html(p(address))
    ```
    
4. __[Q]{.Q}__: Currently the HTML doesn't look terribly pretty, and it's hard to see the
   structure. How could you adapt `tag()` to do indenting and formatting? (You may need to do some research into block and inline tags.)
   
   __[A]{.solved}__: First let us define all needed functions from the textbook:
    
    ```{r required code from book, include=FALSE}
    tag <- function(tag) {
      new_function(
        exprs(... = ),
        expr({
          dots <- dots_partition(...)
          attribs <- html_attributes(dots$named)
          children <- map_chr(dots$unnamed, escape)
          html(paste0(
            !!paste0("<", tag), attribs, ">",
            paste(children, collapse = ""),
            !!paste0("</", tag, ">")
            ))
          }),
        
        caller_env()
      )
    }
    
    void_tag <- function(tag) {
      new_function(
        exprs(... = ), 
        expr({
          dots <- dots_partition(...)
          if (length(dots$unnamed) > 0) {
            stop(!!paste0("<",
                          tag,
                          "> must not have unnamed arguments"),
                 call. = FALSE)
          }
          
          attribs <- html_attributes(dots$named)
          
          html(paste0(!!paste0("<", tag), attribs, " />"))
          }),
        caller_env()
      )
    }
    
    tags <- c("a", "abbr", "address", "article", "aside", "audio", "b",
              "bdi", "bdo", "blockquote", "body", "button", "canvas",
              "caption","cite", "code", "colgroup", "data", "datalist",
              "dd", "del","details", "dfn", "div", "dl", "dt", "em",
              "eventsource","fieldset", "figcaption", "figure", "footer",
              "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header",
              "hgroup", "html", "i","iframe", "ins", "kbd", "label", "legend",
              "li", "mark", "map","menu", "meter", "nav", "noscript", "object",
              "ol", "optgroup", "option", "output", "p", "pre", "progress", "q",
              "ruby", "rp","rt", "s", "samp", "script", "section", "select",
              "small", "span", "strong", "style", "sub", "summary", "sup",
              "table", "tbody", "td", "textarea", "tfoot", "th", "thead",
              "time", "title", "tr", "u", "ul", "var", "video")
    
    void_tags <- c("area", "base", "br", "col", "command", "embed", "hr", "img",
                   "input", "keygen", "link", "meta", "param", "source", 
                   "track", "wbr")
    
    html_tags <- c(tags %>% set_names() %>% map(tag),
                   void_tags %>% set_names() %>% map(void_tag)
                   )
    
    with_html <- function(code) {
      code <- enquo(code)  
      eval_tidy(code, html_tags)
    }
    ```

   Now, let's look at the example from above:

    ```{r, error=TRUE}
    with_html(
      body(
        h1("A heading", id = "first"),
        p("Some text &", b("some bold text.")),
        img(src = "myimg.png", width = 100, height = 100)
        )
    )
    ```

   The formatting comes down to just one long line of code. This output will be more difficult to work with, to inspect what the code does and if it's correct. What kind of formatting would we prefer instead? The [Google HTML Styleguide](https://google.github.io/styleguide/htmlcssguide.html#HTML_Formatting_Rules) suggests *indentation* by 2 spaces and *new lines* for every block, list, or table element. There are other recommendations, but we will keep things simple and will be satisfied with the following output.

    ```{html, eval=FALSE}
    <body>
      <h1 id='first'>A heading</h1>
      <p>Some text &amp;<b>some bold text.</b></p>
      <img src='myimg.png'width='100' height='100' />
    </body>
    ```
    
   First we adjust the `print.advr_html` method. We replace the `strwrap` function, because this will wrap HTML-code into one long line regardless of its input. We use `cat` instead, because it prints linebreaks (`"\n"`) nicely.
    
    ```{r}
    html <- function(x) structure(x, class = "advr_html")
    cat_line <- function(...) cat(..., sep = "")
    
    print.advr_html <- function(x, ...) {
      out <- paste("<HTML>", x, sep = "\n")  # linebreak added
      # cat_line(paste(strwrap(out), collapse = ""))
      cat_line(out)
    }
    ```
    
   In our desired output we can see, that the content of the `body`-function requires another formatting than the other tag-functions. We will therefore create a new `format_code`-function, that allows for optional indentation and linbreaks. For this `strwarp` provides two helpful arguments: each element will start with a linebreak (`prefix = "\n"`) and will be indentend propely (`indent = 2`).
    
    ```{r}
    format_code <- function(children, indent = FALSE){
      if (indent) {
        paste0(paste(strwrap(children, indent = 2, prefix = "\n"),
                     collapse = ""), "\n")
      } else {
        paste(children, collapse = "") 
      }
    }
    ```
    
   We adjust the body function to include the `format_code()`-helper. (This could also be approached programatically in the tag function factory.)
    
    ```{r}
    html_tags$body <- function(...){
      attribs <- caller_env(0) %>%
        as.list() %>%
        Filter(function(x) !is.symbol(x), .) %>%
        html_attributes()
      
      dots <- validate_dots(...)
      children <- map_chr(dots$unnamed, ~escape(., escape_choice = "content"))
      
      html(paste0("<body",
                  attribs, ">",
                  # instead of `paste(children, collapse = "")`
                  format_code(children, indent = TRUE),  
                  "</body>")
      )
    }
    ```
    
   The resulting output is much more satisfying.
    
    ```{r, error=TRUE}
    with_html(
      body(
        h1("A heading", id = "first"),
        p("Some text &", b("some bold text.")),
        img(src = "myimg.png", width = 100, height = 100)
        )
    )
    ```

## LaTeX

1. __[Q]{.Q}__: Add escaping. The special symbols that should be escaped by adding a backslash in front of them are `\`, `$`, and `%`. Just as with HTML, you'll need to make sure you don't end up double-escaping. So you'll need to create a small S3 class and then use that in function operators. That will also allow you to embed arbitrary LaTeX if needed.
    
   __[A]{.solved}__:

2. __[Q]{.Q}__: Complete the DSL to support all the functions that `plotmath` supports.

   __[A]{.solved}__:
