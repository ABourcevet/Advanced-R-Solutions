# Profiling

## Has somebody already solved the problem?

1.  __<span style="color:red">Q</span>__: What are faster alternatives to `lm`? Which are specifically designed 
    to work with larger datasets?
        
    __<span style="color:green">A</span>__: Within the [Cran task view](https://cran.rstudio.com/web/views/) for [HighPerformanceComputing](https://cran.rstudio.com/web/views/HighPerformanceComputing.html) we can find for example the `speedglm` package and it's `speedlm()` function. We might not gain any performanceimprovements on small datasets:
    
    ```{r}
    stopifnot(all.equal(
      coef(speedglm::speedlm(Sepal.Length ~ Sepal.Width + Species, data = iris)),
      coef(lm(Sepal.Length ~ Sepal.Width + Species, data = iris))))

    microbenchmark::microbenchmark(
      speedglm::speedlm(Sepal.Length ~ Sepal.Width + Species, data = iris),
      lm(Sepal.Length ~ Sepal.Width + Species, data = iris)
    )
    ```
    
    However on bigger datasets it can make a difference:
    
    ```{r}
    eps <- rnorm(100000)
    x1 <- rnorm(100000, 5, 3)
    x2 <- rep(c("a", "b"), 50000)
    y <- 7 * x1 + (x2 == "a") + eps
    td <- data.frame(y = y, x1 = x1, x2 = x2, eps = eps)
    
    stopifnot(all.equal(
      coef(speedglm::speedlm(y ~ x1 + x2, data = td)),
      coef(lm(y ~ x1 + x2, data = td))))
    
    microbenchmark::microbenchmark(
      speedglm::speedlm(y ~ x1 + x2, data = td),
      lm(y ~ x1 + x2, data = td)
    )
    ```
    
    For further speedinprovements, you might consider switching your linear algebra libraries as stated in `?speedglm::speedlm`
    
    > The functions of class 'speedlm' may speed up the fitting of LMs to large data sets. High performances can be obtained especially if R is linked against an optimized BLAS, such as ATLAS.
    
    Note that there are many other opportunities mentioned in the task view, also some that make it possible to handle data which is not in memory. 
    
    When it comes to pure speed a quick google search on [r fastest lm](http://stackoverflow.com/questions/25416413/is-there-a-faster-lm-function) provides a stackoverflow thread where someone already solved this problem for us...

1.  __<span style="color:red">Q</span>__: What package implements a version of `match()` that's faster for
    repeated lookups? How much faster is it?
    
    __<span style="color:green">A</span>__: Again google gives a good recommendation for the searchterm [r faster match](http://stackoverflow.com/questions/32934933/faster-in-operator):
    
    ```{r}
    set.seed(1)
    table <- 1L:100000L
    x <- sample(table, 10000, replace=TRUE)
    
    stopifnot(all.equal(match(x, table), fastmatch::fmatch(x, table)))
    
    microbenchmark::microbenchmark(
      match(x, table),
      fastmatch::fmatch(x, table)
    )
    ```
    
    On my laptop `fastmatch::fmatch()` is around 25 times as fast as `match()`.

1.  __<span style="color:red">Q</span>__: List four functions (not just those in base R) that convert a string into a
    date time object. What are their strengths and weaknesses?
    
    __<span style="color:orange">A</span>__: At least these functions will do the trick: `as.POSIXct()`, `as.POSIXlt()`, `strftime()`, `strptime()`, `lubridate::ymd_hms()`. There might also be some in the timeseries packages `xts` or `zoo` and in `anytime`. An update on this will follow...

1.  __<span style="color:red">Q</span>__: How many different ways can you compute a 1d density estimate in R?
    
    __<span style="color:green">A</span>__: According to [Deng and Wickham (2011)](https://www.google.de/url?sa=t&rct=j&q=&esrc=s&source=web&cd=3&ved=0ahUKEwim0sTI9JLRAhVScFAKHdLuBOIQFggxMAI&url=http%3A%2F%2Fvita.had.co.nz%2Fpapers%2Fdensity-estimation.pdf&usg=AFQjCNFBdOT4DvSTXtGoawIFkgf6JlXV9Q&sig2=APnTeIL55Zj_0oATw15mBA&cad=rja) density estimation is implemented in over 20 R packages. 

1.  __<span style="color:red">Q</span>__: Which packages provide the ability to compute a rolling mean?
    
    __<span style="color:green">A</span>__: Again google [r rolling mean](http://stackoverflow.com/questions/743812/calculating-moving-average-in-r)
provides us with enough information and guides our attention on solutions in the following packages:
    * `zoo`
    ```{r}
    zoo::rollmean(1:10, 2, na.pad = TRUE, align = "left")
    zoo::rollapply(1:10, 2, mean, fill = NA, align = "left")
    ```
    * `TTR`
    ```{r}
    TTR::SMA(1:10, 2)
    ```
    * `RcppRoll`
    ```{r}
    RcppRoll::roll_mean(1:10, n = 2, fill = NA, align = "left")
    ```
    * `caTools`
    ```{r}
    caTools::runmean(1:10, k = 2, endrule = "NA", align = "left")
    ```

    Note that an exhaustive example on how to create a rolling mean function is provided in the [textbook](http://adv-r.had.co.nz/Functionals.html).

1.  __<span style="color:red">Q</span>__: What are the alternatives to `optim()`?
    
    __<span style="color:green">A</span>__: Depending on the usecase a lot of different options might be considered. For a general overview we would suggest the corresponding taskview on [Optimization](https://cran.r-project.org/web/views/Optimization.html).

## Do as little as possible

1.  __<span style="color:red">Q</span>__: How do the results change if you compare `mean()` and `mean.default()`
    on 10,000 observations, rather than on 100?
    
    __<span style="color:green">A</span>__: We start with 100 observations as shown in the textbook:
    
    ```{r}
    x <- runif(1e2)
    microbenchmark::microbenchmark(
      mean(x),
      mean.default(x)
    )
    ```
    
    In case of 10000 observations we can observe that using `mean.default()` preserves only a small advantage over the use of `mean()`:
    
    ```{r}
    x <- runif(1e4)
    microbenchmark::microbenchmark(
      mean(x),
      mean.default(x),
      unit = "ns"
    )
    ```
    
    When using even more observations - like in the next lines - it seems that `mean.default` doesn't preserve anymore any advantage at all:
    
    ```{r}
    x <- runif(1e6)
    microbenchmark::microbenchmark(
      mean(x),
      mean.default(x),
      unit = "ns"
    )
    ```

1.  __<span style="color:red">Q</span>__: The following code provides an alternative implementation of `rowSums()`.
    Why is it faster for this input?

    ```{r}
    rowSums2 <- function(df) {
      out <- df[[1L]]
      if (ncol(df) == 1) return(out)
      
      for (i in 2:ncol(df)) {
        out <- out + df[[i]]
      }
      out
    }
    
    df <- as.data.frame(
      replicate(1e3, sample(100, 1e4, replace = TRUE))
    )
    system.time(rowSums(df))
    system.time(rowSums2(df))
    ```
    
    __<span style="color:green">A</span>__: 

1.  __<span style="color:red">Q</span>__: What's the difference between `rowSums()` and `.rowSums()`?
    
    __<span style="color:green">A</span>__: `.rowSums()` is defined as
    
    ```{r}
    .rowSums
    ```
    
    this means, that the internal `rowSums()` function is called via `.Internal()`.
    
    > .Internal performs a call to an internal code which is built in to the R
    interpreter.
    
    The internal `rowSums()` is a complete different function than the "normal"
    `rowSums()` function.
    
    Of course (since they have the same name) in this case these functions are heavily related with each other: If we look into the source code of `rowSums()`, we see that it is a wrapper around the internal `rowSums()`. Just some input checkings, conversions and the special cases (complex numbers) are added:
    
    ```{r}
    rowSums
    ```

1.  __<span style="color:red">Q</span>__: Make a faster version of `chisq.test()` that only computes the chi-square
    test statistic when the input is two numeric vectors with no missing
    values. You can try simplifying `chisq.test()` or by coding from the 
    [mathematical definition](http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test).
    
    __<span style="color:green">A</span>__: Since `chisq.test()` has a relatively long source code, we try a new implementation from scratch:
    
    ```{r}
    chisq.test2 <- function(x, y){
      
      # Input
      if(!is.numeric(x)){
        stop("x must be numeric")}
      if(!is.numeric(y)){
        stop("y must be numeric")}
      if(length(x) != length(y)){
        stop("x and y must have the same length")}
      if(length(x) <= 1){
        stop("length of x must be greater one")}
      if(any(c(x,y) < 0)){
        stop("all entries of x and y must be greater or equal zero")}
      if(sum(complete.cases(x, y)) != length(x)){
        stop("there must be no missing values in x and y")}
      if(any(is.null(c(x,y)))){
        stop("entries of x and y must not be NULL")}
      
      # Help variables
      m <- matrix(c(x, y), nrow = 2, byrow = TRUE)
      margin1 <- rowSums(m)
      margin2 <- colSums(m)
      n <- sum(m)
      me <- tcrossprod(margin1, margin2) / n
      
      # Output
      x_stat = sum((m - me)^2 / me)
      dof <- (length(margin1) - 1) * (length(margin2) - 1)
      p <- pchisq(x_stat, df = dof, lower.tail = FALSE)
      
      return(list(x_stat = x_stat, df = dof, `p-value` = p))
    }
    ```
    
    We check if our new implementation returns the same results
    
    ```{r}
    a <- 21:25
    b <- c(21,23,25,27,29)
    m_test <- cbind(a, b)
    
    chisq.test(m_test)
    chisq.test2(a, b)
    ```
    
    Finally we benchmark this implementation against a compiled version of itself and the original `stats::chisq.test()`:
    
    ```{r}
    chisq.test2c <- compiler::cmpfun(chisq.test2)
    
    microbenchmark::microbenchmark(
      chisq.test(m_test),
      chisq.test2(a, b),
      chisq.test2c(a, b)
    )
    ```

1.  __<span style="color:red">Q</span>__: Can you make a faster version of `table()` for the case of an input of
    two integer vectors with no missing values? Can you use it to
    speed up your chi-square test?
    
    __<span style="color:green">A</span>__: 

1.  __<span style="color:red">Q</span>__: Imagine you want to compute the bootstrap distribution of a sample
    correlation using `cor_df()` and the data in the example below. Given that you 
    want to run this many times, how can you make this code faster? (Hint: the 
    function has three components that you can speed up.)

    ```{r, eval = FALSE}
    n <- 1e6
    df <- data.frame(a = rnorm(n), b = rnorm(n))

    cor_df <- function(i) {
      i <- sample(seq(n), n * 0.01)
      cor(q[i, , drop = FALSE])[2,1]
    }
    ```

    Is there a way to vectorise this procedure?
    
    __<span style="color:green">A</span>__: 

## Vectorise

1.  __<span style="color:red">Q</span>__: The density functions, e.g., `dnorm()`, have a common interface. Which 
    arguments are vectorised over? What does `rnorm(10, mean = 10:1)` do?
    
    __<span style="color:green">A</span>__: 

1.  __<span style="color:red">Q</span>__: Compare the speed of `apply(x, 1, sum)` with `rowSums(x)` for varying sizes
    of `x`.
    
    __<span style="color:green">A</span>__: 
  
1.  __<span style="color:red">Q</span>__: How can you use `crossprod()` to compute a weighted sum? How much faster is
    it than the naive `sum(x * w)`?
    
    __<span style="color:green">A</span>__: 